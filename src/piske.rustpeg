use ast::*;
use sindra::Node;
use sindra::float::float_ext;
use sindra::int::int_ext;
use sindra::string::{match_str_ext, convert_string};
use regex::Regex;

#[pub]
program -> Node<Program>
    = b:block { Node::new(Program(b)) }

#[pub]
block -> Node<Block>
    = vec:(ws stmt:statement ws { stmt })* { Node::new(Block(vec)) }

#[pub]
statement -> Node<Statement>
    = declare_statement
    / assign_statement
    / fn_define_statement
    / expr:expression ws ";"? ws { Node::new(Statement::Expression(expr)) }

fn_define_statement -> Node<Statement>
    = kw_fn fn_ident:identifier ws '(' vec:(ws params:parameters { params }) ')' ws "->" ws
        ret_type:identifier ws "{" body:block "}" {
            Node::new(Statement::FnDefine(FunctionDef { name: fn_ident,
                ret_type: ret_type, params: vec, body: body }))
        }

parameters -> Vec<Node<Parameter>>
    = parameter_ws**","

parameter_ws -> Node<Parameter>
    = ws p:parameter ws { p }

parameter -> Node<Parameter>
    = ident:identifier ws ":" ws ty:identifier { Node::new(Parameter { name: ident.clone(),
        ty: ty.clone() }) }

declare_statement -> Node<Statement>
    = kw_let ident:identifier ws "=" expr:expression ws (";" ws)? {
        Node::new(Statement::Declare(ident, expr))
    }

assign_statement -> Node<Statement>
    = ident:identifier  ws "=" expr:expression ws (";" ws)? {
        Node::new(Statement::Assign(ident, expr))
    }

//global_statement -> Statement
//    = kw_global ws id:identifier ws "(" ws expr:expression ws ")" ws (";" ws)? {
//        Statement::GlobalSet(id, expr)
//    }

keyword<k> = k !@"\p{XID_Continue}"@ ws
kw_let = keyword<"let">
kw_fn = keyword<"fn">
kw_global = keyword<"set">

kw = kw_let / kw_global / kw_fn;

type -> Node<Identifier>
    = primitive_type / identifier

primitive_type -> Node<Identifier>
    = 'real' { Node::new(Identifier("real".to_string())) }
    / 'int' { Node::new(Identifier("int".to_string())) }

#[pub]
arith_expression -> Node<Expression>
    = infix_arith
    / signed_or_unsigned_primary

expression_ws -> Node<Expression>
    = ws e:expression ws { e }

#[pub]
expression -> Node<Expression>
    = i:identifier ws "(" ws pl:arg_list ws ")" {
        Node::new(Expression::FnCall { name: i, args: pl })
    }
    / "{" ws b:block ws "}" { Node::new(Expression::Block(b)) }
    / arith_expression
    / lit:literal { Node::new(Expression::Literal(lit)) }

arg_list -> Vec<Node<Expression>>
    = expression_ws**","

atom -> Node<Expression>
    = ws n:num ws { Node::new(Expression::Literal(n)) }
    / ws i:identifier ws { Node::new(Expression::Identifier(i)) }
    / ws g:grouped_arith ws { g }

conjugated_atom -> Node<Expression>
    = a:atom ws "`" {
        Node::new(Expression::Postfix { op: PostfixOp::Conjugate, left: Box::new(a) })
    }

primary -> Node<Expression>
    = ws c:conjugated_atom ws { c }
    / ws a:atom ws { a }

signed_primary -> Node<Expression>
    = ws "+" p:primary {
        Node::new(Expression::Prefix { op: PrefixOp::UnaryPlus, right: Box::new(p) })
     }
    / ws "-" p:primary {
        Node::new(Expression::Prefix { op: PrefixOp::UnaryMinus, right: Box::new(p) })
    }

signed_or_unsigned_primary -> Node<Expression>
    = primary
    / signed_primary

grouped_arith -> Node<Expression>
    = "(" expr:arith_expression ")" { expr }

infix_arith -> Node<Expression> = #infix<signed_or_unsigned_primary> {
    #L l "+" r {
        Node::new(Expression::Infix { op: InfixOp::Add, left: Box::new(l), right: Box::new(r) })
    }
       l "-" r {
        Node::new(Expression::Infix { op: InfixOp::Subtract, left: Box::new(l), right: Box::new(r) })
    }
    #L l "*" r {
        Node::new(Expression::Infix { op: InfixOp::Multiply, left: Box::new(l), right: Box::new(r) })
    }
       l "/" r {
        Node::new(Expression::Infix { op: InfixOp::Divide, left: Box::new(l), right: Box::new(r) })
    }
    #R l "^" r {
        Node::new(Expression::Infix { op: InfixOp::Power, left: Box::new(l), right: Box::new(r) })
    }
}

ws = #quiet<(ws_char / eol / comment)*>

eol
    = "\n"
    / "\r\n"
    / "\r"
    / "\u{2028}"
    / "\u{2029}"

eol_char = [\n\r\u{2028}\u{2029}]

ws_char
    = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]

comment
    = comment_single_line
    / comment_multi_line

comment_single_line
    = "//" (!eol_char .)*

comment_multi_line
    = "/*" (!"*/" .)* "*/"

#[pub]
literal -> Node<Literal>
    = num
    / string

num -> Node<Literal>
    = f:#ext<float> { Node::new(Literal::Float(f)) }
    / i:#ext<int> { Node::new(Literal::Int(i)) }

str -> String
    = s:#ext<match_str> {? convert_string(s) }

string -> Node<Literal>
    = s:str { Node::new(Literal::String(s)) }

identifier -> Node<Identifier>
    = !kw s:@"\p{XID_Start}\p{XID_Continue}*"@ {
        Node::new(Identifier(s.get(0).unwrap().as_str().to_string()))
    }
